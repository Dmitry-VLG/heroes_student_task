# Heroes_Student_Task

Проект содержит реализации четырёх интерфейсов из `heroes_task_lib`:

- `GeneratePreset` → `programs.GeneratePresetImpl`
- `SimulateBattle` → `programs.SimulateBattleImpl`
- `SuitableForAttackUnitsFinder` → `programs.SuitableForAttackUnitsFinderImpl`
- `UnitTargetPathFinder` → `programs.UnitTargetPathFinderImpl`

---

## Запуск игры

1. Соберираем JAR проекта.
2. В распакованной игре заменяем файл `heroes/jars/obf.jar` на собранный JAR.
3. Запустите игру:
    - «Начать новую игру» → «Создать армию».
    - Нажимаем «Сгенерировать пресет» — игра вызовет `GeneratePresetImpl.generate(...)` и создаст армию компьютера.
    - Расставляем армию игрока на правой стороне поля по красной линии.
    - Нажмаем «Создать армию», и нажимаем «Начать бой» — игра вызовет `SimulateBattleImpl.simulate(...)`.

---

## Сборка JAR в IntelliJ IDEA

1. `File → Project Structure → Artifacts`
2. `+ → JAR → From modules with dependencies`
3. В поле Output directory указываем стандартный путь вида:
   `.../out/artifacts/<artifact_name>/`
4. `Build → Build Artifacts... → <ваш артефакт> → Build`

Готовый JAR появится в `out/artifacts/<artifact_name>/`.

---

## Реализации и алгоритмы

### 1) GeneratePresetImpl (генерация армии компьютера)

**Цель:** сформировать пресет армии противника (левая сторона поля: `x = 0..2`) с ограничением:
- не более 11 юнитов каждого типа,
- суммарная стоимость не больше `maxPoints`,
- выбор максимально эффективного состава по:
    1) `baseAttack / cost` (главный критерий),
    2) `health / cost` (вторичный критерий).

**Алгоритм (жадный):**
1. Берём шаблоны юнитов из входного `unitList` (по одному на каждый тип).
2. Сортируем типы по эффективности: (атака/стоимость) ↓, затем (здоровье/стоимость) ↓.
3. Пока есть очки и свободные клетки:
    - выбираем лучший тип, который:
        - не достиг лимита 11,
        - помещается в оставшиеся очки,
    - создаём нового `Unit`, назначаем координаты на левой стороне, добавляем в армию.
4. Возвращаем `Army` с `units` и `points`.

**Сложность:**
- Сортировка типов: `O(n log n)`, где `n` — количество типов (обычно 4).
- Формирование армии: максимум `N` добавлений; на каждом шаге просмотр `n` типов → `O(n·N)`.
- Итог: `O(n log n + n·N)` (при фиксированном `n` фактически линейно по `N`).

---

### 2) SimulateBattleImpl (симуляция боя)

**Цель:** корректно провести бой по раундам:
- каждый раунд: собрать живых юнитов двух армий,
- отсортировать по убыванию `baseAttack`,
- юниты ходят по очереди согласно этому порядку,
- после каждого хода вызывается логгер `PrintBattleLog`.

**Алгоритм:**
1. Пока у обеих армий есть живые юниты:
    - собрать список всех живых юнитов,
    - сортировать по `baseAttack` ↓,
    - для каждого юнита (если он ещё жив):
        - вызвать `unit.getProgram().attack()`,
        - вызвать `printBattleLog.printBattleLog(attacker, target)`.

**Сложность:**
- Пусть `n` — число живых юнитов в раунде.
- На раунд: сбор `O(n)`, сортировка `O(n log n)`, ходы `O(n)`.
- Итог: `O(R · n log n)`, где `R` — число раундов.

---

### 3) SuitableForAttackUnitsFinderImpl (доступные цели)

**Цель:** из `unitsByRow` (3 ряда противника) выбрать юнитов, доступных для атаки:
- если `isLeftArmyTarget = true` (атакуют левую армию), в каждом ряду выбирается самый правый юнит (максимальный `x`),
- если `isLeftArmyTarget = false` (атакуют правую армию), выбирается самый левый юнит (минимальный `x`).

**Сложность:**
- Один проход по всем юнитам: `O(X·Y)`, где `X` — юнитов в ряду, `Y` — рядов (фиксировано 3).
- Фактически линейно по числу юнитов.

---

### 4) UnitTargetPathFinderImpl (кратчайший путь)

**Цель:** найти кратчайший путь на сетке `WIDTH=27`, `HEIGHT=21` от атакующего юнита до цели,
учитывая препятствия (клетки, занятые другими живыми юнитами). Диагонали разрешены.
Возвращается список `Edge` от старта до цели включительно либо пустой список.

**Алгоритм:** поиск кратчайшего пути на сетке (BFS / Дейкстра для равных весов).
- `visited` + `prev` для восстановления пути.
- Восстанавливаем путь от цели к старту и разворачиваем.

**Сложность:**
- Каждая клетка обрабатывается не более 1 раза; переходов константно (8 направлений).
- `O(WIDTH · HEIGHT)` по времени и памяти.

---

## Примечания

- Реализации находятся в пакете `programs` и собираются в один JAR вместе с зависимостями.
- Логи боя выводятся через `PrintBattleLog`.
