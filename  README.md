# Heroes Student Task (heroes_task)

Проект содержит реализации четырёх интерфейсов из `heroes_task_lib`:

- `GeneratePreset` → `programs.GeneratePresetImpl`
- `SimulateBattle` → `programs.SimulateBattleImpl`
- `SuitableForAttackUnitsFinder` → `programs.SuitableForAttackUnitsFinderImpl`
- `UnitTargetPathFinder` → `programs.UnitTargetPathFinderImpl`

---

## Как проверить решение в игре

1. Соберите JAR проекта (см. раздел «Сборка JAR» ниже).
2. В распакованной игре замените файл `heroes/jars/obf.jar` на собранный JAR (имя можно оставить `obf.jar`).
3. Запустите игру:
    - «Начать новую игру» → «Создать армию».
    - Нажмите «Сгенерировать пресет» — игра вызовет `GeneratePresetImpl.generate(...)` и создаст армию компьютера.
    - Расставьте армию игрока на правой стороне поля по красной линии.
    - Нажмите «Создать армию», вернитесь в меню боя и нажмите «Начать бой» — игра вызовет `SimulateBattleImpl.simulate(...)`.

---

## Сборка JAR в IntelliJ IDEA

1. `File → Project Structure → Artifacts`
2. `+ → JAR → From modules with dependencies`
3. В поле Output directory укажите стандартный путь вида:
   `.../out/artifacts/<artifact_name>/`
4. `Build → Build Artifacts... → <ваш артефакт> → Build`

Готовый JAR появится в `out/artifacts/<artifact_name>/`.

---

## Реализации и алгоритмы

### 1) GeneratePresetImpl (генерация армии компьютера)

**Цель:** сформировать пресет армии противника (левая сторона поля: `x = 0..2`) с ограничением:
- не более 11 юнитов каждого типа,
- суммарная стоимость не больше `maxPoints`,
- выбор максимально эффективного состава по:
    1) `baseAttack / cost` (главный критерий),
    2) `health / cost` (вторичный критерий).

**Алгоритм (жадный):**
1. Берём шаблоны юнитов из входного `unitList` (по одному на каждый тип).
2. Сортируем типы по эффективности: (атака/стоимость) ↓, затем (здоровье/стоимость) ↓.
3. Пока есть очки и свободные клетки:
    - выбираем лучший тип, который:
        - не достиг лимита 11,
        - помещается в оставшиеся очки,
    - создаём нового `Unit`, назначаем координаты на левой стороне, добавляем в армию.
4. Возвращаем `Army` с `units` и `points`.

**Сложность:**
- Сортировка типов: `O(T log T)`, где `T` — количество типов (обычно 4).
- Формирование армии: максимум `N` добавлений; на каждом шаге просмотр `T` типов → `O(T·N)`.
- Итог: `O(T log T + T·N)` (при фиксированном `T` фактически линейно по `N`).

---

### 2) SimulateBattleImpl (симуляция боя)

**Цель:** корректно провести бой по раундам:
- каждый раунд: собрать живых юнитов двух армий,
- отсортировать по убыванию `baseAttack`,
- юниты ходят по очереди согласно этому порядку,
- после каждого хода вызывается логгер `PrintBattleLog`.

**Алгоритм:**
1. Пока у обеих армий есть живые юниты:
    - собрать список всех живых юнитов,
    - сортировать по `baseAttack` ↓,
    - для каждого юнита (если он ещё жив):
        - вызвать `unit.getProgram().attack()`,
        - вызвать `printBattleLog.printBattleLog(attacker, target)`.

**Сложность:**
- Пусть `U` — число живых юнитов в раунде.
- На раунд: сбор `O(U)`, сортировка `O(U log U)`, ходы `O(U)`.
- Итог: `O(R · U log U)`, где `R` — число раундов.

---

### 3) SuitableForAttackUnitsFinderImpl (доступные цели)

**Цель:** из `unitsByRow` (3 ряда противника) выбрать юнитов, доступных для атаки:
- если `isLeftArmyTarget = true` (атакуют левую армию), в каждом ряду выбирается самый правый юнит (максимальный `x`),
- если `isLeftArmyTarget = false` (атакуют правую армию), выбирается самый левый юнит (минимальный `x`).

**Сложность:**
- Один проход по всем юнитам: `O(X·Y)`, где `X` — юнитов в ряду, `Y` — рядов (фиксировано 3).
- Фактически линейно по числу юнитов.

---

### 4) UnitTargetPathFinderImpl (кратчайший путь)

**Цель:** найти кратчайший путь на сетке `WIDTH=27`, `HEIGHT=21` от атакующего юнита до цели,
учитывая препятствия (клетки, занятые другими живыми юнитами). Диагонали разрешены.
Возвращается список `Edge` от старта до цели включительно либо пустой список.

**Алгоритм:** поиск кратчайшего пути на сетке (BFS / Дейкстра для равных весов).
- `visited` + `prev` для восстановления пути.
- Восстанавливаем путь от цели к старту и разворачиваем.

**Сложность:**
- Каждая клетка обрабатывается не более 1 раза; переходов константно (8 направлений).
- `O(WIDTH · HEIGHT)` по времени и памяти.

---

## Примечания

- Реализации находятся в пакете `programs` и собираются в один JAR вместе с зависимостями.
- Логи боя выводятся через `PrintBattleLog` (инжектится игрой/тестами).
